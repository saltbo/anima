# v0.7 — CLI & Developer Experience

Make Anima usable by others, not just itself.

## CLI architecture

CLI follows the same delegation pattern as the 6 pipeline steps:

- **kernel/cli.py** (human-maintained): command parsing, dispatch, simple
  state operations (reset, log, instruct)
- **wiring.py** (agent-modifiable): maps command logic to implementations
- **modules/** (agent-built): complex business logic for commands

Commands that are pure state/IO operations stay fully in kernel.
Commands with complex business logic delegate through wiring.

| Command     | Kernel (dispatch) | Wiring (inject) | Notes                       |
|-------------|:-:|:-:|-----------------------------|
| `start`     | ✓ | ✓ | Already delegates via wiring |
| `status`    | ✓ | ✓ | Data via wiring, display in kernel (rich output can be injected later) |
| `reset`     | ✓ |   | Pure state operation         |
| `log`       | ✓ |   | Pure read                    |
| `instruct`  | ✓ |   | Pure write                   |
| `init`      | ✓ | ✓ | Detection + generation logic in modules |
| `approve`   | ✓ | ✓ | Gate logic in modules (requires v0.6) |

## `anima init` — Inject autonomy into an existing project

The init command does NOT scaffold a new project from scratch. It adds
autonomous iteration capability to an **existing** project — like `git init`
adds version control.

### Core flow

1. **Detect**: Scan the project to identify tech stacks automatically.
   - `package.json` → Node/React/TypeScript
   - `go.mod` → Go
   - `pyproject.toml` / `setup.py` → Python
   - `Cargo.toml` → Rust
   - Full-stack projects may detect multiple stacks in subdirectories.

2. **Configure**: Generate `.anima/toolchain.toml` from detection results.
   Each tech stack entry defines lint, typecheck, test, and coverage commands:
   ```toml
   [[toolchain]]
   path = "backend/"
   lint = "golangci-lint run"
   typecheck = ""
   test = "go test ./..."

   [[toolchain]]
   path = "frontend/"
   lint = "eslint ."
   typecheck = "tsc --noEmit"
   test = "vitest run"
   ```
   The kernel executes these commands generically (run command, check exit
   code) without knowing what specific tools they are.

3. **Guide**: Create a `VISION.md` template for the human to fill in.
   The `--template` flag selects a vision template matching the project type:
   ```bash
   anima init                      # auto-detect stack, generic VISION template
   anima init --template web-app   # auto-detect stack, web app VISION template
   anima init --template cli-tool  # auto-detect stack, CLI tool VISION template
   ```
   Tech stack detection is always automatic; templates only affect VISION.md.

4. **Initialize**: Create `.anima/` directory, initial state, and SOUL.md.

### Design principle

- Tech stack is **detected** (toolchain) — machine-readable, auto-generated
- Project direction is **chosen** (vision template) — human-authored, guided

## Checklist

- [x] Tech stack detection (scan project files for known markers)
- [ ] `.anima/toolchain.toml` generation from detection results
- [ ] VISION.md templates for common project types (web-app, cli-tool, library)
- [ ] `anima init` command wiring + module implementation
- [ ] `anima approve` command wiring + module implementation (requires v0.6 gate)
- [ ] Rich terminal output: progress bars, colored status, iteration summaries
- [ ] Published to PyPI, installable via `uv tool install anima`
- [ ] All code passes full quality pipeline
