"""Tests for the toolchain_writer module.

Validates SPEC.md behavior: TOML generation from DetectionResult,
file writing, and edge cases.
"""

from __future__ import annotations

import tomllib
from pathlib import Path

from domain.models import DetectionResult, ToolchainEntry
from modules.toolchain_writer.core import generate_toml, write_toolchain

# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

_PYTHON_ENTRY = ToolchainEntry(
    path=".",
    stack="python",
    lint="ruff check .",
    typecheck="pyright",
    test="pytest",
    coverage="pytest --cov",
)

_NODE_ENTRY = ToolchainEntry(
    path="frontend/",
    stack="node",
    lint="eslint .",
    typecheck="tsc --noEmit",
    test="npm test",
    coverage="",
)

_GO_ENTRY = ToolchainEntry(
    path="backend/",
    stack="go",
    lint="golangci-lint run",
    typecheck="",
    test="go test ./...",
    coverage="go test -coverprofile=coverage.out ./...",
)

_RUST_ENTRY = ToolchainEntry(
    path="engine/",
    stack="rust",
    lint="cargo clippy",
    typecheck="",
    test="cargo test",
    coverage="",
)


# ---------------------------------------------------------------------------
# generate_toml — pure function tests
# ---------------------------------------------------------------------------


class TestGenerateToml:
    """Tests for generate_toml()."""

    def test_empty_result_returns_header_only(self) -> None:
        """Empty DetectionResult produces only the header comment."""
        result = DetectionResult(entries=())
        toml = generate_toml(result)
        assert toml.startswith("# Generated by anima init")
        assert "[[toolchain]]" not in toml

    def test_empty_result_is_valid_toml(self) -> None:
        """Even the empty output is valid TOML."""
        result = DetectionResult(entries=())
        parsed = tomllib.loads(generate_toml(result))
        assert parsed == {}

    def test_single_entry(self) -> None:
        """Single entry produces one [[toolchain]] section."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        toml = generate_toml(result)
        parsed = tomllib.loads(toml)
        assert len(parsed["toolchain"]) == 1
        assert parsed["toolchain"][0]["stack"] == "python"
        assert parsed["toolchain"][0]["path"] == "."

    def test_single_entry_all_fields(self) -> None:
        """All six fields are present in the TOML output."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        parsed = tomllib.loads(generate_toml(result))
        entry = parsed["toolchain"][0]
        assert entry["path"] == "."
        assert entry["stack"] == "python"
        assert entry["lint"] == "ruff check ."
        assert entry["typecheck"] == "pyright"
        assert entry["test"] == "pytest"
        assert entry["coverage"] == "pytest --cov"

    def test_multiple_entries(self) -> None:
        """Multiple entries produce multiple [[toolchain]] sections."""
        result = DetectionResult(entries=(_PYTHON_ENTRY, _NODE_ENTRY, _GO_ENTRY))
        parsed = tomllib.loads(generate_toml(result))
        assert len(parsed["toolchain"]) == 3

    def test_entry_order_preserved(self) -> None:
        """Entries appear in the same order as the input."""
        result = DetectionResult(entries=(_GO_ENTRY, _PYTHON_ENTRY, _NODE_ENTRY))
        parsed = tomllib.loads(generate_toml(result))
        stacks = [e["stack"] for e in parsed["toolchain"]]
        assert stacks == ["go", "python", "node"]

    def test_empty_string_fields_present(self) -> None:
        """Empty string fields are included in the output."""
        result = DetectionResult(entries=(_NODE_ENTRY,))
        parsed = tomllib.loads(generate_toml(result))
        assert parsed["toolchain"][0]["coverage"] == ""

    def test_empty_typecheck_field(self) -> None:
        """Go entry has empty typecheck field."""
        result = DetectionResult(entries=(_GO_ENTRY,))
        parsed = tomllib.loads(generate_toml(result))
        assert parsed["toolchain"][0]["typecheck"] == ""

    def test_all_four_stacks(self) -> None:
        """All four supported stacks serialize correctly."""
        result = DetectionResult(entries=(_PYTHON_ENTRY, _NODE_ENTRY, _GO_ENTRY, _RUST_ENTRY))
        parsed = tomllib.loads(generate_toml(result))
        stacks = {e["stack"] for e in parsed["toolchain"]}
        assert stacks == {"python", "node", "go", "rust"}

    def test_output_ends_with_newline(self) -> None:
        """Output always ends with a trailing newline."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        assert generate_toml(result).endswith("\n")

    def test_header_comment_present(self) -> None:
        """The header comment is always the first line."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        first_line = generate_toml(result).split("\n")[0]
        assert first_line.startswith("# Generated by anima init")

    def test_sections_separated_by_blank_line(self) -> None:
        """Multiple [[toolchain]] sections are separated by blank lines."""
        result = DetectionResult(entries=(_PYTHON_ENTRY, _NODE_ENTRY))
        toml = generate_toml(result)
        # The header ends, then a blank line, then first section,
        # then a blank line, then second section.
        assert "\n\n[[toolchain]]" in toml

    def test_special_characters_in_path(self) -> None:
        """Paths with special characters are escaped correctly."""
        entry = ToolchainEntry(
            path='dir "quoted"/',
            stack="python",
            lint="ruff check .",
            typecheck="",
            test="pytest",
            coverage="",
        )
        result = DetectionResult(entries=(entry,))
        parsed = tomllib.loads(generate_toml(result))
        assert parsed["toolchain"][0]["path"] == 'dir "quoted"/'

    def test_backslash_in_command(self) -> None:
        """Backslashes in commands are escaped correctly."""
        entry = ToolchainEntry(
            path=".",
            stack="custom",
            lint="lint\\check",
            typecheck="",
            test="test",
            coverage="",
        )
        result = DetectionResult(entries=(entry,))
        parsed = tomllib.loads(generate_toml(result))
        assert parsed["toolchain"][0]["lint"] == "lint\\check"


# ---------------------------------------------------------------------------
# write_toolchain — file I/O tests
# ---------------------------------------------------------------------------


class TestWriteToolchain:
    """Tests for write_toolchain()."""

    def test_creates_file(self, tmp_path: Path) -> None:
        """Writes toolchain.toml in the given directory."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        anima_dir = str(tmp_path / ".anima")
        path = write_toolchain(result, anima_dir)
        assert Path(path).exists()
        assert Path(path).name == "toolchain.toml"

    def test_creates_directory(self, tmp_path: Path) -> None:
        """Creates the .anima directory if it does not exist."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        anima_dir = str(tmp_path / "nested" / ".anima")
        write_toolchain(result, anima_dir)
        assert Path(anima_dir).is_dir()

    def test_file_content_is_valid_toml(self, tmp_path: Path) -> None:
        """Written file content is valid TOML."""
        result = DetectionResult(entries=(_PYTHON_ENTRY, _NODE_ENTRY))
        anima_dir = str(tmp_path / ".anima")
        path = write_toolchain(result, anima_dir)
        content = Path(path).read_text(encoding="utf-8")
        parsed = tomllib.loads(content)
        assert len(parsed["toolchain"]) == 2

    def test_returns_absolute_path(self, tmp_path: Path) -> None:
        """Returned path is absolute."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        anima_dir = str(tmp_path / ".anima")
        path = write_toolchain(result, anima_dir)
        assert Path(path).is_absolute()

    def test_overwrites_existing_file(self, tmp_path: Path) -> None:
        """Overwrites an existing toolchain.toml."""
        anima_dir = str(tmp_path / ".anima")
        Path(anima_dir).mkdir(parents=True)
        (Path(anima_dir) / "toolchain.toml").write_text("old content")

        result = DetectionResult(entries=(_GO_ENTRY,))
        path = write_toolchain(result, anima_dir)
        content = Path(path).read_text(encoding="utf-8")
        assert "old content" not in content
        assert "[[toolchain]]" in content

    def test_empty_result_writes_header_only(self, tmp_path: Path) -> None:
        """Empty detection result writes a file with only the header."""
        result = DetectionResult(entries=())
        anima_dir = str(tmp_path / ".anima")
        path = write_toolchain(result, anima_dir)
        content = Path(path).read_text(encoding="utf-8")
        assert "[[toolchain]]" not in content
        assert "Generated by anima init" in content

    def test_file_is_utf8(self, tmp_path: Path) -> None:
        """Written file uses UTF-8 encoding."""
        result = DetectionResult(entries=(_PYTHON_ENTRY,))
        anima_dir = str(tmp_path / ".anima")
        path = write_toolchain(result, anima_dir)
        # Reading with UTF-8 should not raise.
        Path(path).read_text(encoding="utf-8")
