You are the AI agent driving Anima, an Autonomous Iteration Engine.
Anima builds itself through iterative development cycles. You are in iteration #14.

======== VISION (read VISION.md for full details) ========
# VISION: Anima

## Identity

**Anima** (Latin: "soul, life force") is an Autonomous Iteration Engine — a system
that gives software projects a life of their own through continuous, goal-driven,
self-directed development cycles.

Anima is also **its own first user**. It builds itself through the same autonomous
iteration process it provides to others. When Anima reaches maturity, its every
release will have been produced by itself.

## Core Principles (Immutable)

1. **Gap-Driven**: Anima iterates only when a gap exists between current state
   and desired state. No gap, no action.
2. **Module Isolation**: Anima is composed of replaceable modules with strict
   interface contracts (Protocols). Any module can be rewritten from scratch
   without affecting others.
3. **Verify Before Commit**: Nothing is committed without passing the full
   verification pipeline (ruff + pyright + pytest). Failed iterations are
   rolled back and their failure is recorded as knowledge.
4. **Seed Replacement**: Anima progressively replaces the seed script's primitive
   logic with its own purpose-built modules. The seed is scaffolding, not architecture.
5. **Human as Visionary**: Humans define *what* and *why*. Anima decides *how* and *when*.
6. **Type Safety as Contract**: All code must have complete type annotations and
   pass strict static analysis. Types are the machine-enforceable form of contracts.
7. **Rewrite Over Patch**: When changes exceed 40% of a module's code, prefer a
   clean rewrite over accumulated patches. Anima writes code fast — use that advantage.

## Architecture

Anima follows **Clean Architecture** principles adapted for an autonomous iteration engine:
dependency flows inward, the core domain has zero external dependencies, and all
external interactions are mediated through abstract Ports implemented by Adapters.

The system is divided into two trust zones:
- **Kernel** (immutable by Anima, human-only modifications)
- **Everything else** (iterable by Anima, subject to verification)

### Directory Structure

```
anima/
├── domain/                    # Core domain — pure Python, ZERO external dependencies
│   ├── models.py              # Core data types (dataclass + full type annotations)
│   │   ├── Vision             # Structured representation of the vision
│   │   ├── ProjectState       # Project state snapshot
│   │   ├── GapReport          # Gap analysis report
│   │   ├── IterationPlan      # What to do in this iteration
│   │   ├── ExecutionResult    # Agent execution output
│   │   ├── VerificationReport # Pass/fail + details
│   │   └── IterationRecord    # Persisted iteration log entry
│   │
│   └── ports.py               # Abstract interfaces for all external dependencies
│       ├── AgentPort           # AI agent abstraction (Protocol)
│       ├── VersionControlPort  # Version control abstraction (Protocol)
│       ├── TestRunnerPort      # Test execution abstraction (Protocol)
│       ├── LinterPort          # Lint + type check abstraction (Protocol)
│       └── FileSystemPort      # File system operations abstraction (Protocol)
│
├── modules/                   # Functional modules (each is a Use Case)
│   ├── gap_analyzer/          # Vision + State → GapReport
│   │   ├── CONTRACT.md
│   │   ├── core.py            # Pure logic, depends only on domain/
│   │   └── tests/
│   ├── planner/               # GapReport + History → IterationPlan
│   │   ├── CONTRACT.md
│   │   ├── core.py
│   │   └── tests/
│   ├── executor/              # IterationPlan → ExecutionResult (via AgentPort)
│   │   ├── CONTRACT.md
│   │   ├── core.py
│   │   └── tests/
│   ├── verifier/              # Pre/Post State → VerificationReport
│   │   ├── CONTRACT.md
│   │   ├── core.py
│   │   └── tests/
│   └── reporter/              # VerificationReport → IterationRecord
│       ├── CONTRACT.md
│       ├── core.py
│       └── tests/
│
├── adapters/                  # Concrete implementations of Ports
│   ├── agents/
│   │   ├── claude_code.py     # ClaudeCodeAdapter implements AgentPort
│   │   ├── codex.py           # CodexAdapter implements AgentPort
│   │   └── gemini.py          # GeminiAdapter implements AgentPort
│   ├── git_vc.py              # GitVersionControl implements VersionControlPort
│   ├── pytest_runner.py       # PytestRunner implements TestRunnerPort
│   ├── quality_checker.py     # RuffPyrightChecker implements LinterPort
│   └── local_fs.py            # LocalFileSystem implements FileSystemPort
│
├── kernel/                    # IMMUTABLE — Anima cannot modify this
│   ├── loop.py                # Iteration loop scheduler
│   ├── rollback.py            # Rollback mechanism
│   └── config.py              # System configuration
│
├── cli/                       # User-facing command-line interface
│   └── main.py                # anima init / start / status / instruct / pause / approve
│
├── inbox/                     # Human intent injection (drop .md files here)
├── iterations/                # Iteration logs (auto-generated)
└── seed.py                    # Bootstrap script (to be replaced by modules)
```

### Clean Architecture Rules

1. **domain/ has ZERO imports from outside the Python standard library.**
   It defines only dataclasses and Protocols. This layer never changes
   unless the fundamental concepts of the system change.

2. **modules/ depend only on domain/.** Each module's core.py receives
   Ports via constructor injection. It never imports from adapters/ or kernel/.

3. **adapters/ implement domain/ports.py Protocols.** They are the only
   code that touches external tools (git, pytest, claude CLI, file system).
   Swapping an adapter requires zero changes to modules.

4. **kernel/ is the trust root.** It orchestrates the iteration loop and
   manages rollback. Anima's self-iteration scope explicitly excludes kernel/.
   Only humans modify kernel/.

5. **Dependency direction: adapters → modules → domain ← kernel.**
   Never the reverse.

### Key Design Patterns

- **Protocol-based interfaces (PEP 544)**: Use `typing.Protocol` for all Ports.
  No inheritance required — structural subtyping means any class with matching
  method signatures satisfies the Protocol. pyright strict mode enforces this.

- **Dataclasses for all domain models**: Use `@dataclass(frozen=True)` for
  immutable value objects. Full type annotations on every field. No `Any` types
  in domain models.

- **Constructor injection**: Modules receive their dependencies (Ports) through
  `__init__`, never through global imports. This makes testing trivial and
  makes the dependency graph explicit.

## Quality Assurance Pipeline

Every iteration must pass this pipeline before changes are committed.
Failure at any stage triggers a rollback.

### Stage 1: Code Formatting & Linting (ruff)

```
ruff check . --fix && ruff format --check .
```

Enforces:
- Consistent code style (replaces black + isort)
- No unused imports or variables
- No overly complex functions (McCabe complexity)
- Docstrings on all public functions
- Import ordering and grouping

### Stage 2: Static Type Checking (pyright strict)

```
pyright --project pyrightconfig.json
```

Enforces:
- Complete type annotations on all functions (parameters + return)
- No implicit `Any` types
- Protocol compliance (all Adapters correctly implement their Ports)
- No unsafe type narrowing
- Proper handling of Optional/None

### Stage 3: Tests & Coverage (pytest + pytest-cov)

```
pytest --cov=anima --cov-fail-under=80 --tb=short -q
```

Enforces:
- All tests pass
- Minimum 80% code coverage
- Each module has at least one test validating its CONTRACT.md

### Pipeline Integration

The verification pipeline is defined as a single command that the Verifier
module (and initially the seed script) runs after every iteration:

```bash
ruff check . && ruff format --check . && pyright && pytest --cov=anima --cov-fail-under=80
```

All four must exit 0 for the iteration to be considered successful.

### Configuration Files

The following configuration files must be created as part of the project
scaffolding (v0.1):

- **pyproject.toml**: Project metadata, ruff configuration, pytest configuration
- **pyrightconfig.json**: pyright strict mode settings, include/exclude paths

## Version Roadmap

See `roadmap/` for per-version checklists:

- roadmap/v0.1.md — Foundation & Toolchain
- roadmap/v0.2.md — Core Modules (Gap Analyzer & Reporter)
- roadmap/v0.3.md — Planner & Executor
- roadmap/v0.4.md — Verifier & Quality Gate
- roadmap/v0.5.md — Kernel & Full Autonomy
- roadmap/v0.6.md — CLI & Developer Experience
- roadmap/v0.7.md — Self-Validation & Benchmark
- roadmap/v1.0.md — Production Ready

## Inbox Protocol

Humans communicate intent by placing Markdown files in the `inbox/` directory:

```
inbox/
├── YYYYMMDD-HHMMSS-short-description.md
```

Each file should contain:

```markdown
# <Short Title>

## What
What should change or be added.

## Why
The motivation or problem being solved.

## Priority
high | medium | low

## Constraints (optional)
Any boundaries, requirements, or things to avoid.
```

The system processes inbox items by priority, incorporating them into
the gap analysis on the next iteration cycle. Processed items are archived
to `inbox/.archive/`.

## Quality Standards

- All code must have complete type annotations (enforced by pyright strict)
- All code must pass ruff linting and formatting checks
- All modules must have ≥80% test coverage
- All module interfaces must be defined as Protocols in domain/ports.py
- Every CONTRACT.md must be written before implementation begins
- Every iteration produces a structured JSON log entry
- Failed iterations are valuable data — always record the failure reason
- Code that passes tests but violates type contracts is a failure
- domain/ must never import from modules/, adapters/, or kernel/
- modules/ must never import from adapters/ or kernel/
- kernel/ is off-limits to Anima's self-iteration


======== CURRENT ROADMAP TARGET (v0.2) ========
# v0.2 — Core Modules (Gap Analyzer & Reporter)

Build the two modules with the simplest contracts first.

- [x] Implement gap_analyzer/core.py: reads Vision + ProjectState, outputs GapReport
- [x] Tests for gap_analyzer validating CONTRACT.md
- [x] Implement reporter/core.py: writes structured IterationRecord to iterations/
- [x] Tests for reporter validating CONTRACT.md
- [ ] Seed delegates gap analysis to gap_analyzer module (first self-replacement)
- [ ] Seed delegates reporting to reporter module (second self-replacement)
- [x] All code passes full quality pipeline


======== CURRENT STATE ========
FILES:
  .coverage
  .gitignore
  LICENSE
  README.md
  VISION.md
  conftest.py
  pyproject.toml
  pyrightconfig.json
  seed.py
  test_claude.sh
  .claude/settings.local.json
  adapters/__init__.py
  adapters/git_vc.py
  adapters/local_fs.py
  adapters/agents/__init__.py
  adapters/tests/__init__.py
  adapters/tests/test_git_vc.py
  adapters/tests/test_local_fs.py
  domain/__init__.py
  domain/models.py
  domain/ports.py
  inbox/20260227-120000-bootstrap-foundation.md
  modules/__init__.py
  modules/executor/CONTRACT.md
  modules/executor/SPEC.md
  modules/executor/__init__.py
  modules/executor/core.py
  modules/executor/tests/__init__.py
  modules/executor/tests/test_executor.py
  modules/gap_analyzer/CONTRACT.md
  modules/gap_analyzer/SPEC.md
  modules/gap_analyzer/__init__.py
  modules/gap_analyzer/core.py
  modules/gap_analyzer/tests/__init__.py
  modules/gap_analyzer/tests/test_gap_analyzer.py
  modules/planner/CONTRACT.md
  modules/planner/SPEC.md
  modules/planner/__init__.py
  modules/planner/core.py
  modules/planner/tests/__init__.py
  modules/planner/tests/test_planner.py
  modules/reporter/CONTRACT.md
  modules/reporter/SPEC.md
  modules/reporter/__init__.py
  modules/reporter/core.py
  modules/reporter/tests/__init__.py
  modules/reporter/tests/test_reporter.py
  modules/verifier/CONTRACT.md
  modules/verifier/SPEC.md
  modules/verifier/__init__.py
  modules/verifier/core.py
  modules/verifier/tests/__init__.py
  modules/verifier/tests/test_verifier.py
  roadmap/v0.1.md
  roadmap/v0.2.md
  roadmap/v0.3.md
  roadmap/v0.4.md
  roadmap/v0.5.md
  roadmap/v0.6.md
  roadmap/v0.7.md
  roadmap/v1.0.md

ARCHITECTURE STATUS:
  domain/ layer: exists
  adapters/ layer: exists
  kernel/ layer: not yet needed
  pyproject.toml: exists
  pyrightconfig.json: exists

MODULE STATUS:
  __pycache__: [empty]
  executor: [contract, spec, core, tests]
  gap_analyzer: [contract, spec, core, tests]
  planner: [contract, spec, core, tests]
  reporter: [contract, spec, core, tests]
  verifier: [contract, spec, core, tests]

QUALITY PIPELINE:
  ruff_lint: ✓
  ruff_format: ✓
  pyright: ✓

TESTS: ✓ passing

RECENT ITERATIONS:
  [✓] All tests passing; New files: 2; Module 'verifier' gained core
  [✓] All tests passing; New files: 2
  [✓] All tests passing; New files: 1

======== GAPS TO ADDRESS ========
UNCOMPLETED ROADMAP ITEMS for v0.2 (2):
  - Seed delegates gap analysis to gap_analyzer module (first self-replacement)
  - Seed delegates reporting to reporter module (second self-replacement)

HUMAN REQUEST (20260227-120000-bootstrap-foundation.md):
# Bootstrap project foundation

## What
Create pyproject.toml, pyrightconfig.json, and the domain layer (models.py + ports.py)
as the first structural foundation for Anima.

## Why
Everything else depends on the domain types and quality toolchain being in place.
Without pyproject.toml there is no ruff/pytest config. Without domain/models.py
and domain/ports.py, modules have no types to work with and no Ports to depend on.

## Priority
high

## Constraints
- domain/ must have ZERO external imports (only stdlib + typing)
- Use @dataclass(frozen=True) for all domain models
- Use typing.Protocol for all port interfaces
- pyproject.toml must configure ruff (strict), pytest (cov>=80), and project metadata
- pyrightconfig.json must enable strict mode


======== YOUR TASK ========
Execute THE SINGLE MOST IMPORTANT next step to advance Anima. Rules:

1. **ONE THING WELL.** Pick the highest-priority gap and address it thoroughly.
   Do not attempt multiple unrelated changes.

2. **FINISH THE CURRENT VERSION FIRST.** Only work on items listed in the
   CURRENT ROADMAP TARGET (v0.2) above. Do NOT start tasks from
   later versions until all items in v0.2 are checked off.

3. **PRIORITY ORDER** (do the first applicable item from the current version):
   a. If quality checks are failing (ruff/pyright) → fix the issues
   b. If tests are failing → fix them
   c. Pick the next unchecked roadmap item and implement it
   d. If inbox has items → incorporate into specs/plans
   e. If all items in current version are done → advance to next roadmap version

4. **ARCHITECTURE RULES** (enforced — violations cause rollback):
   - domain/ must have ZERO external imports (only stdlib + typing)
   - modules/*/core.py must only import from domain/
   - adapters/ implement Protocols defined in domain/ports.py
   - Use @dataclass(frozen=True) for domain models
   - Use typing.Protocol for all port interfaces
   - Complete type annotations on ALL functions (params + return types)
   - No `Any` type in domain models

5. **FILE LOCATIONS**:
   - Domain types: domain/models.py
   - Port interfaces: domain/ports.py
   - Module logic: modules/<name>/core.py
   - Module contracts: modules/<name>/CONTRACT.md
   - Module specs: modules/<name>/SPEC.md
   - Module tests: modules/<name>/tests/test_<name>.py
   - Adapters: adapters/<name>.py or adapters/<category>/<name>.py
   - Config: pyproject.toml, pyrightconfig.json (project root)

6. **CONTRACT.md FORMAT**:
   ```
   # <Module Name> Contract
   ## Purpose
   One sentence.
   ## Input
   What this module receives (with Python types from domain/models.py).
   ## Output
   What this module produces (with Python types from domain/models.py).
   ## Dependencies
   Which Ports (from domain/ports.py) this module requires.
   ## Constraints
   Rules and invariants.
   ```

6. **DO NOT MODIFY these files** (they are protected):
   - seed.py
   - VISION.md
   - Anything in kernel/ (if it exists)
   - Anything in roadmap/ (managed by seed.py auto-check)

Now execute. Create or modify files to address the most important gap.
After making changes, verify them by running: ruff check . && pyright && python -m pytest
